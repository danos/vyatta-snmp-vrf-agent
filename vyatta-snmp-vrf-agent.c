/*
 *  Copyright (c) 2018-2019, AT&T Intellectual Property. All rights reserved.
 *  Copyright (c) 2016 by Brocade Communications Systems, Inc.
 *  All rights reserved.
 * 
 *  SPDX-License-Identifier: BSD-3-Clause
 */
/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.7 $ of : subagent.m2c,v $ 
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include "mibII/ip.h"
#include "mibII/ipv6.h"
#include "net-snmp/data_access/interface.h"
#include "ip-mib/ipAddressPrefixTable/ipAddressPrefixTable.h"
#include "ip-mib/ipAddressTable/ipAddressTable.h"
#include "ip-mib/ipDefaultRouterTable/ipDefaultRouterTable.h"
#include "ip-mib/ipIfStatsTable/ipIfStatsTable.h"
#include "ip-forward-mib/inetCidrRouteTable/inetCidrRouteTable.h"
#include "ip-forward-mib/ipCidrRouteTable/ipCidrRouteTable.h"

extern void register_ipv6_context(char *);
extern void register_table_inetCidrRouteTable(char *);
extern void register_table_ipCidrRouteTable(char *);
extern void register_table_ipDefaultRouterTable(char *);
extern void register_table_ipIfStatsTable(char *);
extern void register_table_ipAddressTable(char *);
extern void register_table_ipAddressPrefixTable(char *);

#include "vrf_manager.h"

#include <signal.h>

static int keep_running;

static RETSIGTYPE
stop_server(int a)
{
    keep_running = 0;
}

#define MODULE_NAME "vyatta-snmp-vrf-agent"

static void
usage(void)
{
    printf
        ("usage: " MODULE_NAME " [-D<tokens>] [-f] [-L] [-M] [-x ADDRESS]\n"
         "\t-f\tDo not fork() from the calling shell.\n"
         "\t-DTOKEN[,TOKEN,...]\n"
         "\t\tTurn on debugging output for the given TOKEN(s).\n"
         "\t\tWithout any tokens specified, it defaults to printing\n"
         "\t\tall the tokens (which is equivalent to the keyword 'ALL').\n"
         "\t\tYou might want to try ALL for extremely verbose output.\n"
         "\t\tNote: You can't put a space between the -D and the TOKENs.\n"
         "\t-M\tRun as a normal SNMP Agent instead of an AgentX sub-agent.\n"
         "\t-x ADDRESS\tconnect to master agent at ADDRESS (default NETSNMP_AGENTX_SOCKET).\n"
         "\t-L\tDo not open a log file; print all messages to stderr.\n");
    exit(0);
}

int
main(int argc, char **argv)
{
    int             agentx_subagent = 1;        /* change this if you want to be a SNMP master agent */
    int             c;
    extern char    *optarg;
    int             background = 1, use_syslog = 0;
    char           *agentx_socket = NULL;
    struct vrf_map *vrf_list = NULL;
    unsigned int    i, num_vrfs;

    while ((c = getopt(argc, argv, "D:fLMx:")) != EOF)
        switch (c) {
        case 'D':
            debug_register_tokens(optarg);
            snmp_set_do_debugging(1);
            break;
        case 'f':
            background = 0;
            break;
        case 'M':
            agentx_subagent = 0;
            break;
        case 'L':
            use_syslog = 0;     /* use stderr */
            break;
        case 'x':
            agentx_socket = optarg;
            break;
        default:
            fprintf(stderr, "unknown option %c\n", c);
            usage();
        }

    /* we're an agentx subagent? */
    if (agentx_subagent) {
        /* make us a agentx client */
        netsnmp_enable_subagent();
        if (NULL != agentx_socket)
            netsnmp_ds_set_string(NETSNMP_DS_APPLICATION_ID,
                                  NETSNMP_DS_AGENT_X_SOCKET,
                                  agentx_socket);
    }

    snmp_disable_log();
    if (use_syslog)
        snmp_enable_calllog();
    else
        snmp_enable_stderrlog();

    /* run in background, if requested */
    if (background && netsnmp_daemonize(1, !use_syslog))
        exit(-1);

    /* initialize tcpip, if necessary */
    SOCK_STARTUP;

    /* initialize the agent library */
    init_agent(MODULE_NAME);

    /* initialize mib code */
    netsnmp_access_interface_init();

#ifndef VRFMASTER_PREFIX
#define VRFMASTER_PREFIX "vrf"
#endif

    num_vrfs = get_vrf_list(&vrf_list);
    for (i = 0; i < num_vrfs; i++)
#ifdef HAVE_ROUTING_DOMAIN
        netsnmp_add_context_rdid(vrf_list[i].vrf_name, vrf_list[i].vrf_id);
#else
        netsnmp_add_context_vrf(&vrf_list[i].vrf_name[strlen(VRFMASTER_PREFIX)],
                                vrf_list[i].vrf_name);
#endif

#define REGISTER_MIB_CONTEXTS(func)                               \
    do {                                                          \
        context_mapping *ptr;                                     \
        for (ptr = get_context_mapping(); ptr; ptr = ptr->next) { \
        if (!ptr->context)                                        \
            continue;                                             \
        (func)(ptr->context);                                     \
        }                                                         \
    } while (0)

    init_ip();
    REGISTER_MIB_CONTEXTS(register_ip_context);

    init_ipv6();
    REGISTER_MIB_CONTEXTS(register_ipv6_context);

    init_ipDefaultRouterTable();
    REGISTER_MIB_CONTEXTS(register_table_ipDefaultRouterTable);

    init_ipIfStatsTable();
    REGISTER_MIB_CONTEXTS(register_table_ipIfStatsTable);

    init_ipAddressTable();
    REGISTER_MIB_CONTEXTS(register_table_ipAddressTable);

    init_ipAddressPrefixTable();
    REGISTER_MIB_CONTEXTS(register_table_ipAddressPrefixTable);

    init_ipCidrRouteTable();
    REGISTER_MIB_CONTEXTS(register_table_ipCidrRouteTable);

    /* read .conf files.  */
    init_snmp(MODULE_NAME);

    /* If we're going to be a snmp master agent, initialize the ports */
    if (!agentx_subagent)
        init_master_agent();    /* open the port to listen on (defaults to udp:161) */

    /* In case we receive a request to stop (kill -TERM or kill -INT) */
    keep_running = 1;
    signal(SIGTERM, stop_server);
    signal(SIGINT, stop_server);

    /* your main loop here... */
    while (keep_running) {
        agent_check_and_process(1);     /* 0 == don't block */
    }

    /* at shutdown time */
    free(vrf_list);
    snmp_shutdown(MODULE_NAME);
    SOCK_CLEANUP;

    exit(0);
}
